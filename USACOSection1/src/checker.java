// Section 1.5

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter;

/*
ID: leonluc1
PROG: checker
LANG: JAVA
*/

// Queens
// The max data : 13 is easy to TLE using classic problem
// Test 1: TEST OK [0.101 secs, 13916 KB]
// Test 2: TEST OK [0.130 secs, 13916 KB]
// Test 3: TEST OK [0.108 secs, 13916 KB]
// Test 4: TEST OK [0.166 secs, 13916 KB]
// Test 5: TEST OK [0.209 secs, 13916 KB]
// Test 6: TEST OK [0.230 secs, 13916 KB]
// Test 7: TEST OK [0.331 secs, 13916 KB]
// Test 8: TEST OK [0.986 secs, 13916 KB] <- very close to TLE [online]
// run on local machine -- data:13 -> 0.358s
// run on LeonIV 0.281s

// check algorithm improvement contributes a lot. great prunning

public class checker {
	private static int MAX;
	private static BufferedReader in;
	private static PrintWriter out;
	//row[i] = col, row i col j
	private static int[] row;
	private static int cnt = 0;
	
	private static int[] colused;
	private static int[] updiagonalused;
	private static int[] downdiagonalused;
	
	public static void main(String[] args) throws Exception{
		long old = System.currentTimeMillis();

		in = new BufferedReader(new FileReader("checker.in"));
		out = new PrintWriter(new BufferedWriter(new FileWriter("checker.out")));
		
		MAX = Integer.parseInt(in.readLine());
		row = new int[MAX];
		colused = new int[MAX];		
		updiagonalused = new int[2*MAX];  // i+j
		downdiagonalused = new int[2*MAX];	// i-j+N
		
		//6 has 4 solutions, which will not be generated by the following algo
		if(MAX <= 6) 
			dfs(0);
		// 7 has 40 solutions, 40/4 = 10 >= 3 which means it's safe to eliminate 3/4 loops
		else{	
			for(int j = 0 ; j < MAX /2; j++){
				row[0] = j;
				addMarkIJ(0,j);
				dfs(1);
				removeMarkIJ(0,j);
			}
			cnt *= 2;
			if(MAX % 2 != 0){	// when MAX is odd
				row[0] = MAX / 2;
				addMarkIJ(0,MAX / 2);
				dfs(1);
				removeMarkIJ(0,MAX / 2);
			}
		}
		out.println(cnt);

		System.out.println("Time elapsed: " +(System.currentTimeMillis() - old)/1000.0);

		out.close();
		System.exit(0);
	}
	
	private static void dfs(int i){
		if(i == MAX){
			cnt ++;
			StringBuilder sb = new StringBuilder();
			if(cnt <=3){
				for(int col : row){
					sb.append(col+1);
					sb.append(" ");
				}
				sb.deleteCharAt(sb.length()-1);
				out.println(sb.toString());
			}
		}
		else
			for(int j = 0; j < MAX; j ++){
				if(colused[j] == 0 && updiagonalused[i+j] == 0 
						&& downdiagonalused[i-j+MAX] == 0){
					row[i] = j; // [row i, j]
					addMarkIJ(i,j);
					dfs(i+1); // next row
					removeMarkIJ(i, j);
				}
			}
	}

	private static void removeMarkIJ(int i, int j) {
		colused[j]--;
		updiagonalused[i+j]--;
		downdiagonalused[i-j+MAX]--;
	}
	
	private static void addMarkIJ(int i, int j){
		colused[j]++;
		updiagonalused[i+j] ++;
		downdiagonalused[i-j+MAX] ++;
	}
}